<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>5 What you need to know about XPath | Data Harvesting with R</title>
<meta name="author" content="Jorge Cimentada">
<meta name="description" content="XPath (XML Path Language) is the language designed to identify the address of one or several tags within an HTML or XML document. With that address, XPath allows us to extract the data under those...">
<meta name="generator" content="bookdown 0.26 with bs4_book()">
<meta property="og:title" content="5 What you need to know about XPath | Data Harvesting with R">
<meta property="og:type" content="book">
<meta property="og:url" content="https://cimentadaj.github.io/dataharvesting/xpath-chapter.html">
<meta property="og:description" content="XPath (XML Path Language) is the language designed to identify the address of one or several tags within an HTML or XML document. With that address, XPath allows us to extract the data under those...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="5 What you need to know about XPath | Data Harvesting with R">
<meta name="twitter:description" content="XPath (XML Path Language) is the language designed to identify the address of one or several tags within an HTML or XML document. With that address, XPath allows us to extract the data under those...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/_Lato-0.4.1/font.css" rel="stylesheet">
<link href="libs/_Roboto%20Mono-0.4.1/font.css" rel="stylesheet">
<link href="libs/_Montserrat-0.4.1/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/htmlwidgets-1.5.4/htmlwidgets.js"></script><link href="libs/str_view-0.1.0/str_view.css" rel="stylesheet">
<script src="libs/str_view-binding-1.4.0/str_view.js"></script><link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
         (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

     ga('create', 'UA-99618359-1', 'auto');
     ga('send', 'pageview');

    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="style/style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h2>
        <a href="index.html" title="">Data Harvesting with R</a>
      </h2>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html"><span class="header-section-number">1</span> Welcome</a></li>
<li class="book-part">Webscraping</li>
<li><a class="" href="primer-webscraping.html"><span class="header-section-number">2</span> A primer on Webscraping</a></li>
<li><a class="" href="data-formats-for-webscraping.html"><span class="header-section-number">3</span> Data Formats for Webscraping</a></li>
<li><a class="" href="regex.html"><span class="header-section-number">4</span> What you need to know about regular expressions</a></li>
<li><a class="active" href="xpath-chapter.html"><span class="header-section-number">5</span> What you need to know about XPath</a></li>
<li><a class="" href="spanish-school.html"><span class="header-section-number">6</span> Case study: Scraping Spanish school locations from the web</a></li>
<li><a class="" href="automating-scripts.html"><span class="header-section-number">7</span> Automating Web Scraping Scripts</a></li>
<li><a class="" href="scraping-javascript-based-website.html"><span class="header-section-number">8</span> Scraping JavaScript based website</a></li>
<li><a class="" href="ethical-issues.html"><span class="header-section-number">9</span> Ethical issues in Web Scraping</a></li>
<li class="book-part">APIs</li>
<li><a class="" href="intro-apis.html"><span class="header-section-number">10</span> Introduction to REST APIs</a></li>
<li><a class="" href="primer-apis.html"><span class="header-section-number">11</span> A primer on APIs</a></li>
<li><a class="" href="a-dialogue-between-computers.html"><span class="header-section-number">12</span> A dialogue between computers</a></li>
<li><a class="" href="json-chapter.html"><span class="header-section-number">13</span> What you need to know about JSON</a></li>
<li><a class="" href="case-study-exploring-the-amazon-api.html"><span class="header-section-number">14</span> Case study: Exploring the Amazon API</a></li>
<li><a class="" href="automating-api-programs-real-time-bicycle-data.html"><span class="header-section-number">15</span> Automating API programs: real-time bicycle data</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/cimentadaj/dataharvesting">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="xpath-chapter" class="section level1" number="5">
<h1>
<span class="header-section-number">5</span> What you need to know about XPath<a class="anchor" aria-label="anchor" href="#xpath-chapter"><i class="fas fa-link"></i></a>
</h1>
<p>XPath (XML Path Language) is the language designed to identify the address of one or several tags within an HTML or XML document. With that address, XPath allows us to extract the data under those tags. For example, take a look at the XML below:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb127-1"><a href="xpath-chapter.html#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;bookshelf&gt;</span></span>
<span id="cb127-2"><a href="xpath-chapter.html#cb127-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">&lt;dansimmons&gt;</span></span>
<span id="cb127-3"><a href="xpath-chapter.html#cb127-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;book&gt;</span></span>
<span id="cb127-4"><a href="xpath-chapter.html#cb127-4" aria-hidden="true" tabindex="-1"></a>      Hyperion Cantos</span>
<span id="cb127-5"><a href="xpath-chapter.html#cb127-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;/book&gt;</span></span>
<span id="cb127-6"><a href="xpath-chapter.html#cb127-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">&lt;/dansimmons&gt;</span></span>
<span id="cb127-7"><a href="xpath-chapter.html#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/bookshelf&gt;</span></span></code></pre></div>
<p>To extract the book ‘Hyperion Cantos’ of Dan Simmons, the simplest XPath you can use is <code>/bookshelf/dansimmons/book</code>. Let’s break that up to understand it better:</p>
<ul>
<li>The first node is bookshelf so we start with <code>/bookshelf</code>.</li>
<li>The <em>child</em> of bookshelf is <code>&lt;dansimmons&gt;</code> so the XPath becomes <code>/bookshelf/dansimmons/</code>
</li>
<li>The <em>child</em> of <code>&lt;dansimmons&gt;</code> is <code>&lt;book&gt;</code> so we just add that to our XPath: <code>/bookshelf/dansimmons/book</code>
</li>
</ul>
<p>That doesn’t look so hard, right? The problem is that for all your web scraping needs, having the exact address, node by node, will not by generalizable.</p>
<div id="finding-tags-with-xpath" class="section level2" number="5.1">
<h2>
<span class="header-section-number">5.1</span> Finding tags with XPath<a class="anchor" aria-label="anchor" href="#finding-tags-with-xpath"><i class="fas fa-link"></i></a>
</h2>
<p>Before we read in that previous XPath let’s load the libraries we’ll need for this chapter.</p>
<div class="sourceCode" id="cb128"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://xml2.r-lib.org/">xml2</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://magrittr.tidyverse.org">magrittr</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">scrapex</span><span class="op">)</span></code></pre></div>
<p>Let’s read in that XML to R and test our initial XPath:</p>
<div class="sourceCode" id="cb129"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">raw_xml</span> <span class="op">&lt;-</span> <span class="st">"
&lt;bookshelf&gt;
  &lt;dansimmons&gt;
    &lt;book&gt;
      Hyperion Cantos
    &lt;/book&gt;
  &lt;/dansimmons&gt;
&lt;/bookshelf&gt;"</span>

<span class="va">book_xml</span> <span class="op">&lt;-</span> <span class="fu"><a href="http://xml2.r-lib.org/reference/read_xml.html">read_xml</a></span><span class="op">(</span><span class="va">raw_xml</span><span class="op">)</span>
<span class="va">direct_address</span> <span class="op">&lt;-</span> <span class="st">"/bookshelf/dansimmons/book"</span>

<span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="va">direct_address</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (1)}
## [1] &lt;book&gt;\n      Hyperion Cantos\n    &lt;/book&gt;</code></pre>
<p>It works as expected. Now you remember what I told you that this specific address was not generalizable? What if someone added the <code>authors</code> tag after bookshelf?</p>
<div class="sourceCode" id="cb131"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Note the new `&lt;authors&gt;` tag, a child of `&lt;bookshelf&gt;`.</span>
<span class="va">raw_xml</span> <span class="op">&lt;-</span> <span class="st">"
&lt;bookshelf&gt;
  &lt;authors&gt;
    &lt;dansimmons&gt;
      &lt;book&gt;
        Hyperion Cantos
      &lt;/book&gt;
    &lt;/dansimmons&gt;
  &lt;/authors&gt;
&lt;/bookshelf&gt;"</span>

<span class="va">book_xml</span> <span class="op">&lt;-</span> <span class="va">raw_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="http://xml2.r-lib.org/reference/read_xml.html">read_xml</a></span><span class="op">(</span><span class="op">)</span>

<span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="va">direct_address</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (0)}</code></pre>
<p>It can’t find it using our previous XPath expression. We know why, it’s because we should instead use the XPath <code>/bookshelf/authors/dansimmons/book</code>. But what if someone (that is, the developer behind the website you’re trying to scrape) continually changes the XML? Can’t we build a more general expression? XPath has some handy tricks that you can use to do that. For example, there’s one thing we know for the book <code>Hyperion Cantos</code>: it was written by Dan Simmons. Instead, you can extract only the <code>&lt;dansimmons&gt;</code> tag directly with <code>//dansimmons</code>. That will return all <code>&lt;dansimmons&gt;</code> tags of the entire XML document. However, since we know there’s only one <code>&lt;dansimmons&gt;</code> tag, we know we’ll be grabbing the one we’re after:</p>
<div class="sourceCode" id="cb133"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (1)}
## [1] &lt;dansimmons&gt;\n  &lt;book&gt;\n        Hyperion Cantos\n      &lt;/book&gt;\n&lt;/dansimm ...</code></pre>
<p><code>//</code> is very handy, it means: search the entire document and bring me back all <code>&lt;dansimmons&gt;</code> tags. It doesn’t matter the depth of the <code>&lt;dansimmons&gt;</code> tag, it could be three or twenty times deep, <code>//</code> will return all occurrences of that tag. Let’s extend the example to include another Dan Simmons book and its release date:</p>
<div class="sourceCode" id="cb135"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Note the new `&lt;release_year&gt;` tag below the second (also new) `&lt;book&gt;` tag</span>
<span class="va">raw_xml</span> <span class="op">&lt;-</span> <span class="st">"
&lt;bookshelf&gt;
  &lt;authors&gt;
    &lt;dansimmons&gt;
      &lt;book&gt;
        Hyperion Cantos
      &lt;/book&gt;
      &lt;book&gt;
        &lt;release_year&gt;
         1996
        &lt;/release_year&gt;
        Endymion
      &lt;/book&gt;
    &lt;/dansimmons&gt;
  &lt;/authors&gt;
&lt;/bookshelf&gt;"</span>

<span class="va">book_xml</span> <span class="op">&lt;-</span> <span class="va">raw_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="http://xml2.r-lib.org/reference/read_xml.html">read_xml</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<p>Can you predict what our XPath will return before running it? Let’s find out:</p>
<div class="sourceCode" id="cb136"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (1)}
## [1] &lt;dansimmons&gt;\n  &lt;book&gt;\n        Hyperion Cantos\n      &lt;/book&gt;\n  &lt;book&gt;&lt; ...</code></pre>
<p>It returns the <code>&lt;dansimmons&gt;</code> tag, which is what we expected. Within <code>&lt;dansimmons&gt;</code> there should be two <code>&lt;book&gt;</code> tags but we can’t see the result of these two tags directly from the output. What we want is to extract the names of both books. We can reuse that idea of using <code>/</code> as before for the <code>book</code> tag. We do this because we know that <code>book</code> is the direct child of <code>dansimmons</code>:</p>
<div class="sourceCode" id="cb138"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons/book"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (2)}
## [1] &lt;book&gt;\n        Hyperion Cantos\n      &lt;/book&gt;
## [2] &lt;book&gt;&lt;release_year&gt;\n         1996\n        &lt;/release_year&gt;\n        End ...</code></pre>
<p>There we go, we get the two book nodes. If <code>book</code> would not be the direct child of <code>&lt;dansimmons&gt;</code>, <code>/</code> wouldn’t work. For example, if instead of <code>book</code> we searched for <code>release_year</code> (the new tag we added as well), it would return an empty node:</p>
<div class="sourceCode" id="cb140"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons/release_year"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (0)}</code></pre>
<p>That’s expected: <code>dansimmons</code> doesn’t have a direct child called <code>release_year</code> (it has a <em>grandchild</em> <code>&lt;release_year&gt;</code>. However, we know that <code>//</code> will search for tags in the entire XML tree so we can instead request all <code>release_year</code> tags inside <code>dansimmons</code>:</p>
<div class="sourceCode" id="cb142"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons//release_year"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (1)}
## [1] &lt;release_year&gt;\n         1996\n        &lt;/release_year&gt;</code></pre>
<p>At this point, it might be useful to know that <code>xml_path</code> can return the literal, direct address to a given node. Exactly like our first XPath from the chapter:</p>
<div class="sourceCode" id="cb144"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons//release_year"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_path.html">xml_path</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] "/bookshelf/authors/dansimmons/book[2]/release_year"</code></pre>
<p>For some concrete cases, using a literal path such as this one might be much quicker than coming up with a single XPath that makes it more general. If you’re trying to scrape something as a one-off thing, manually navigating a HTML/XML tree (with functions such as <code>xml_child</code> or directly in the web developer tools of your browser) and copying it’s exact XPath location might be the better choice.</p>
<p>XPath also allows to hand pick nodes by position. Within the <code>dansimmons</code> tag there are two book tags. What would an XPath expression look like to subset only the 2nd <code>&lt;book&gt;</code> tag of <code>dansimmons</code>? We can tell XPath the position of the tag we want using <code>[number]</code>, where number is replaced with the position:</p>
<div class="sourceCode" id="cb146"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons/book[2]"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (1)}
## [1] &lt;book&gt;&lt;release_year&gt;\n         1996\n        &lt;/release_year&gt;\n        End ...</code></pre>
<p>You can supply the position of any node. As expected, this will return empty if the position doesn’t exist:</p>
<div class="sourceCode" id="cb148"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons/book[8]"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (0)}</code></pre>
<p>However, throughout all of these examples we had to be very specific in supplying the exact address of some child node with respect to it’s parent. <code>//dansimmons</code> will return all <code>dansimmons</code> tags but we won’t be able to see its children. We would need to know which specific book tags are children of <code>dansimmons</code>, if there are any. XPath introduces the <code>*</code> as a wildcard pattern to return all children of current parent tag. For example:</p>
<div class="sourceCode" id="cb150"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons/*"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (2)}
## [1] &lt;book&gt;\n        Hyperion Cantos\n      &lt;/book&gt;
## [2] &lt;book&gt;&lt;release_year&gt;\n         1996\n        &lt;/release_year&gt;\n        End ...</code></pre>
<p>The result is not the <code>dansimmons</code> tag but all it’s children, regardless of whether they are <code>&lt;book&gt;</code> tags or any other tag. This strategy is useful if you’re unsure which nodes are below a certain parent and you want to extract all of them: this is in fact very generalizable because you can extract all children of a tag and then pick the one you’re after with some string manipulation.</p>
<p>Similarly, <code>*</code> can be used to fill out a tag which you don’t know the name of. You know that each author has <code>&lt;book&gt;</code> tags but you don’t know the name of all authors. You could extract all book tags like this:</p>
<div class="sourceCode" id="cb152"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"/*/*/*/book"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (2)}
## [1] &lt;book&gt;\n        Hyperion Cantos\n      &lt;/book&gt;
## [2] &lt;book&gt;&lt;release_year&gt;\n         1996\n        &lt;/release_year&gt;\n        End ...</code></pre>
<p>In other words, this XPath is saying: extract all book tags which have three tags above it, it doesn’t matter <em>which</em> tags they are. As we’ll see later in this chapter, this is quite a nice trick for more complex HTML/XML structures.</p>
<p>Let’s recap so far:</p>
<ul>
<li>
<code>/</code> links between two tags that have direct parent-child relationship</li>
<li>
<code>//</code> finds all tags in the HTML/XML tree regardless of depth</li>
<li>Use <code>[number]</code> to subset the position of a node. For example: <code>//a[8]</code> will return the 8th <code>&lt;a&gt;</code> tag.</li>
<li>
<code>*</code> is a wildcard that allows to signal nodes without specifying which nodes.</li>
</ul>
<p>These rules can take you a long way when building XPath expressions but the real flexibility comes when you’re available to filter through attributes of a given node.</p>
</div>
<div id="filter-by-attributes" class="section level2" number="5.2">
<h2>
<span class="header-section-number">5.2</span> Filter by attributes<a class="anchor" aria-label="anchor" href="#filter-by-attributes"><i class="fas fa-link"></i></a>
</h2>
<p>When parsing complicated websites, you’ll need additional flexibility to parse HTML/XML. XPath has a great property that allows to pick tags with specific attributes. Let’s update our XML example to include a new author tag <code>&lt;stephenking&gt;</code>, one of it’s books and some additional attributes for some books:</p>
<div class="sourceCode" id="cb154"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Note the new &lt;stephenking&gt; tag with it's book 'The Stand' and all &lt;book&gt; tags have some attributes</span>
<span class="va">raw_xml</span> <span class="op">&lt;-</span> <span class="st">"
&lt;bookshelf&gt;
  &lt;authors&gt;
    &lt;dansimmons&gt;
      &lt;book price='yes' topic='scifi'&gt;
        Hyperion Cantos
      &lt;/book&gt;
      &lt;book topic='scifi'&gt;
        &lt;release_year&gt;
         1996
        &lt;/release_year&gt;
        Endymion
      &lt;/book&gt;
    &lt;/dansimmons&gt;
    &lt;stephenking&gt;
    &lt;book price='yes' topic='horror'&gt;
     The Stand
    &lt;/book&gt;
    &lt;/stephenking&gt;
  &lt;/authors&gt;
&lt;/bookshelf&gt;"</span>

<span class="va">book_xml</span> <span class="op">&lt;-</span> <span class="va">raw_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="http://xml2.r-lib.org/reference/read_xml.html">read_xml</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<p>The power of XPath comes in when we can filter tags by attributes. Perhaps we’d like to extract all book tags that had a price, regardless of author. Or catch all books of a certain topic. Whenever we want our tags to match a specific attribute we can add two brackets at the end of the tag and match the attribute to what we’re after. Say we wanted to know all Dan Simmons book with a price, how would that XPath look like?</p>
<div class="sourceCode" id="cb155"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//dansimmons//book[@price='yes']"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_text.html">xml_text</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] "\n        Hyperion Cantos\n      "</code></pre>
<p>Our new XPath is saying: find all <code>&lt;book&gt;</code> tags that have an attribute of <code>price</code> set to <code>yes</code> that are <em>descendants</em> (but not necessarily direct child, because of the <code>//</code>) of the <code>&lt;dansimmons&gt;</code> tag. Quite interesting eh? This approach allows us to have a much flexible language for parsing HTML/XML documents. Everything inside <code>[]</code> serves to add additional filters/criteria that matches your XPath. With the help of the <code>and</code> keyword, you can alter the previous XPath to get all books with a price from the topic <code>horror</code>:</p>
<div class="sourceCode" id="cb157"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//book[@price='yes' and @topic='horror']"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_text.html">xml_text</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] "\n     The Stand\n    "</code></pre>
<p>Or grab only the books which have a <code>price</code> attribute (that’s different from having <code>price</code> set to <code>yes</code> or <code>no</code>):</p>
<div class="sourceCode" id="cb159"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//book[@price]"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (2)}
## [1] &lt;book price="yes" topic="scifi"&gt;\n        Hyperion Cantos\n      &lt;/book&gt;
## [2] &lt;book price="yes" topic="horror"&gt;\n     The Stand\n    &lt;/book&gt;</code></pre>
<p>Or find all books which did not have a price:</p>
<div class="sourceCode" id="cb161"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//book[@price!='yes']"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (0)}</code></pre>
<p>This is correct because there is not attribute of price set to ‘no’. You can also use the keyword <code>or</code> to match certain properties:</p>
<div class="sourceCode" id="cb163"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">book_xml</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//book[@price='yes' or @topic='scifi']"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_text.html">xml_text</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] "\n        Hyperion Cantos\n      "                  
## [2] "\n         1996\n        \n        Endymion\n      "
## [3] "\n     The Stand\n    "</code></pre>
<p>XPath has all the goodies to perform basic filtering (<code>and</code>, <code>or</code>, <code>=</code>, <code>!=</code>) but also has additional functions that are useful for filtering. Some of the most common ones include:</p>
<ul>
<li><code><a href="https://tidyselect.r-lib.org/reference/starts_with.html">contains()</a></code></li>
<li><code>starts-with()</code></li>
<li><code><a href="https://rdrr.io/r/graphics/text.html">text()</a></code></li>
<li><code><a href="https://magrittr.tidyverse.org/reference/aliases.html">not()</a></code></li>
<li><code><a href="https://dplyr.tidyverse.org/reference/count.html">count()</a></code></li>
</ul>
<p>How do we use them? We always use these functions within the context of filtering (everything used inside <code>[]</code>). With these you can reach a level of fine-grained filtering that can save you hours searching on the source code of an XML/HTML document. Before we go over some of the cases where these functions are useful, let’s load a new example from the <code>scrapex</code> package.</p>
<p>For the rest of the chapter and the exercises you’ll be working with the main page of the newspaper “El País”. “El País” is an international daily newspaper. It is the among the most circulated newspapers in Spain and has a very rich website that we’ll be scraping. We can load it from the function <code><a href="https://rdrr.io/pkg/scrapex/man/elpais_newspaper_ex.html">elpais_newspaper_ex()</a></code>:</p>
<div class="sourceCode" id="cb165"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">newspaper_link</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/scrapex/man/elpais_newspaper_ex.html">elpais_newspaper_ex</a></span><span class="op">(</span><span class="op">)</span>
<span class="va">newspaper</span> <span class="op">&lt;-</span> <span class="fu"><a href="http://xml2.r-lib.org/reference/read_xml.html">read_html</a></span><span class="op">(</span><span class="va">newspaper_link</span><span class="op">)</span></code></pre></div>
<p>Let’s look at the website in our web browser:</p>
<div class="sourceCode" id="cb166"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/browseURL.html">browseURL</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/scrapex/man/prep_browser.html">prep_browser</a></span><span class="op">(</span><span class="va">newspaper_link</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="images/xpath/elpais_main.png" width="100%" style="display: block; margin: auto;"></div>
<p>The website has news organized along the left, right and center of the website. If you scroll down you’ll see there are dozens more news snippets scattered throughout the website. These news are organized through sections such as ‘Culture’, ‘Sports’ and ‘Business’.</p>
<p>Let’s say we’re interested in figuring out the links to all sections of the newspaper to be able to scrape all news separately by area. To avoid complexity, we’ll start by first grabbing the ‘Science’ section link as a first step. The section you want to explore is here:</p>
<div class="inline-figure"><img src="images/xpath/elpais_science_main.png" width="100%" style="display: block; margin: auto;"></div>
<p>On the left you can see the section ‘Science, Tech &amp; Health’ and the articles that belong to that section. The words ‘Science, Tech &amp; Health’ in bold contain a hyperlink to that main page on science articles. That’s what we want to access. On the right, you’ll see that I opened the web developer tools from the browser. After clicking manually on ‘Science, Tech &amp; Health’ on the right, the source code highlights in blue where the hyperlink is.</p>
<p>More concretely, you can see on the source code that you want an <code>&lt;a&gt;</code> tag that is nested within a <code>&lt;section&gt;</code> tag (two tags above the <code>&lt;a&gt;</code> tag). That <code>&lt;a&gt;</code> tag has an attribute <code>href</code> that contains the link:</p>
<div class="inline-figure"><img src="images/xpath/elpais_science_main_sourcecode.png" width="100%" style="display: block; margin: auto;"></div>
<p>Ok, with this information we can be creative and build an XPath expressions that says: find all the <code>&lt;a&gt;</code> tags that have an <code>href</code> attribute containing the word ‘Science’ and also inherits from a <code>&lt;section&gt;</code> tag:</p>
<div class="sourceCode" id="cb167"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section//a[contains(@href, 'science')]"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (20)}
##  [1] &lt;a href="https://english.elpais.com/science-tech/2022-10-07/is-climate-c ...
##  [2] &lt;a href="https://english.elpais.com/science-tech/2022-10-07/worlds-top-m ...
##  [3] &lt;a href="https://english.elpais.com/science-tech/" class="b_h_t _pr"&gt;Sci ...
##  [4] &lt;a href="https://english.elpais.com/science-tech/2022-10-07/a-new-drug-t ...
##  [5] &lt;a href="https://english.elpais.com/science-tech/2022-10-07/a-new-drug-t ...
##  [6] &lt;a href="https://english.elpais.com/science-tech/2022-10-06/european-med ...
##  [7] &lt;a href="https://english.elpais.com/science-tech/2022-10-06/european-med ...
##  [8] &lt;a href="https://english.elpais.com/science-tech/2022-10-06/ophiuchus-th ...
##  [9] &lt;a href="https://english.elpais.com/science-tech/2022-10-06/ophiuchus-th ...
## [10] &lt;a href="https://english.elpais.com/science-tech/2022-09-17/one-girls-ge ...
## [11] &lt;a href="https://english.elpais.com/science-tech/2022-09-17/one-girls-ge ...
## [12] &lt;a href="https://english.elpais.com/science-tech/2022-10-06/global-warmi ...
## [13] &lt;a href="https://english.elpais.com/science-tech/2022-10-06/global-warmi ...
## [14] &lt;a href="https://english.elpais.com/science-tech/" class="b_h_t _pr"&gt;Sci ...
## [15] &lt;a href="https://english.elpais.com/science-tech/2022-10-06/how-can-a-sm ...
## [16] &lt;a href="https://english.elpais.com/science-tech/2022-10-06/how-can-a-sm ...
## [17] &lt;a href="https://english.elpais.com/science-tech/2022-10-04/the-orbit-of ...
## [18] &lt;a href="https://english.elpais.com/science-tech/2022-10-06/european-med ...
## [19] &lt;a href="https://english.elpais.com/science-tech/2022-10-01/rare-diamond ...
## [20] &lt;a href="https://english.elpais.com/science-tech/2022-09-30/carole-hoove ...</code></pre>
<p>Hmm, the XPath seems right but the output returns too many tags. We were expecting one link that is the general science section (something like <code>https://english.elpais.com/science-tech/</code>). We know that between our <code>&lt;a&gt;</code> tag and <code>&lt;section&gt;</code> tag there are two additional <code>&lt;header&gt;</code> and <code>&lt;div&gt;</code> tags:</p>
<div class="inline-figure"><img src="images/xpath/elpais_science_main_sourcecode.png" width="100%" style="display: block; margin: auto;"></div>
<p>These two exact tags might not be the same for all other sections but we can try specifying two wild cards tags in between <code>&lt;section&gt;</code> and <code>&lt;a&gt;</code>. For example:</p>
<div class="sourceCode" id="cb169"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section/*/*/a[contains(@href, 'science')]"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (2)}
## [1] &lt;a href="https://english.elpais.com/science-tech/" class="b_h_t _pr"&gt;Scie ...
## [2] &lt;a href="https://english.elpais.com/science-tech/" class="b_h_t _pr"&gt;Scie ...</code></pre>
<p>That’s the one we were looking for. Let’s explain the XPath expression:</p>
<ul>
<li>
<code>//section</code> means to search for all sections throughout the HTML tree</li>
<li>
<code>//section/*/*</code> means to search for two <em>direct</em> children of <code>&lt;section&gt;</code> (regardless of what these tags are)</li>
<li>
<code>a[contains(@href, 'science')]</code> finds the <code>&lt;a&gt;</code> tags for which the <code>@href</code> attribute contains the text ‘science’.</li>
<li>The final expression says: finds all <code>&lt;a&gt;</code> tags for which the <code>@href</code> attribute contains the text ‘science’ which are descendant of the <code>&lt;section&gt;</code> tag with two tags in between.</li>
</ul>
<p>As it might become evident, the function <code>contains</code> searches for text in an attribute. It matches that the supplied text is contained in the attribute that you want. Kinda like in regular expressions. However you can also use it with the function <code><a href="https://rdrr.io/r/graphics/text.html">text()</a></code> which points to the actual text of the tag. We could rewrite the previous XPath to make it even more precise:</p>
<div class="sourceCode" id="cb171"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section/*/*/a[contains(text(), 'Science, Tech &amp; Health')]"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_attr.html">xml_attr</a></span><span class="op">(</span><span class="st">"href"</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] "https://english.elpais.com/science-tech/"</code></pre>
<p>Instead, this XPath grabs all <code>&lt;a&gt;</code> tags which contain the text ‘Science, Tech &amp; Health’. In fact, we could make it even shorter. Since probably no <code>&lt;a&gt;</code> tag contains the text ‘Science, Tech &amp; Health’, we can remove the wildcards <code>*</code> for the tags:</p>
<div class="sourceCode" id="cb173"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section//a[contains(text(), 'Science, Tech &amp; Health')]"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_attr.html">xml_attr</a></span><span class="op">(</span><span class="st">"href"</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] "https://english.elpais.com/science-tech/"</code></pre>
<p>This final expression asks for all <code>&lt;a&gt;</code> tags which are descendants of the <code>&lt;section&gt;</code> tags that contains the specific science text. These functions (<code>text</code>, <code>contains</code>) make the filtering much more precise and easy to understand. Other functions such as <code>start-with()</code> perform the same job as <code><a href="https://tidyselect.r-lib.org/reference/starts_with.html">contains()</a></code> but matching whether an attribute/text starts with some provided text.</p>
<p>The function <code><a href="https://magrittr.tidyverse.org/reference/aliases.html">not()</a></code> is also useful for filtering. It negates everything inside a filter expression. With out previous example, using <code><a href="https://magrittr.tidyverse.org/reference/aliases.html">not()</a></code> will return all sections which are not the ones containing the text ‘Science, Tech &amp; Health’:</p>
<div class="sourceCode" id="cb175"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section/*/*/a[not(contains(text(), 'Science, Tech &amp; Health'))]"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_attr.html">xml_attr</a></span><span class="op">(</span><span class="st">"href"</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] "https://english.elpais.com/economy-and-business/"                                                                                               
##  [2] "https://english.elpais.com/opinion/the-global-observer/"                                                                                        
##  [3] "https://english.elpais.com/international/"                                                                                                      
##  [4] "https://english.elpais.com/culture/"                                                                                                            
##  [5] "https://english.elpais.com/science-tech/"                                                                                                       
##  [6] "https://english.elpais.com/society/"                                                                                                            
##  [7] "https://elpais.com/archivo/#?prm=hemeroteca_pie_ep"                                                                                             
##  [8] "https://elpais.com/archivo/#?prm=hemeroteca_pie_ep"                                                                                             
##  [9] "https://play.google.com/store/apps/details?id=com.elpais.elpais&amp;hl=es&amp;gl=US"                                                                    
## [10] "https://apps.apple.com/es/app/el-pa%C3%ADs/id301049096"                                                                                         
## [11] "https://elpais.com/suscripciones/#/campaign#?prod=SUSDIGCRART&amp;o=susdig_camp&amp;prm=pw_suscrip_cta_pie_eng&amp;backURL=https%3A%2F%2Fenglish.elpais.com"</code></pre>
<p>We see the links to all other sections such as <code>economy-and-business</code> and <code>international</code>. Finally, the function <code><a href="https://dplyr.tidyverse.org/reference/count.html">count()</a></code> allows you to use conditionals based on counting something. One interesting question is how many sections have over three articles. You might be interested in scraping newspaper sites to measure whether there is any bias in the amount of news published in certain sections. An XPath that directly tackles this might be like this:</p>
<div class="sourceCode" id="cb177"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section[count(.//article)&gt;3]"</span><span class="op">)</span></code></pre></div>
<pre><code>## {xml_nodeset (5)}
## [1] &lt;section class="_g _g-md _g-o b b-d" data-dtm-region="portada_apertura"&gt;&lt; ...
## [2] &lt;section class="b b-t b-t-ad _g-o " data-dtm-region="portada_tematicos_sc ...
## [3] &lt;section class="b b-m _g-o" data-dtm-region="portada_arrevistada_culture" ...
## [4] &lt;section class="b b-t b-t-df b-t-1 _g-o " data-dtm-region="portada_temati ...
## [5] &lt;section class="b b-t b-t-df b-t-1 _g-o " data-dtm-region="portada_temati ...</code></pre>
<p>By looking at the result we see that the attribute <code>data-dtm-region</code> contains some information about the name of the section (see the word culture in the third node). Let’s extract it:</p>
<div class="sourceCode" id="cb179"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section[count(.//article)&gt;3]"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_attr.html">xml_attr</a></span><span class="op">(</span><span class="st">"data-dtm-region"</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] "portada_apertura"                          
## [2] "portada_tematicos_science,-tech-&amp;-health"  
## [3] "portada_arrevistada_culture"               
## [4] "portada_tematicos_celebrities,-movies-&amp;-tv"
## [5] "portada_tematicos_our-selection"</code></pre>
<p>Five sections, mostly entertainment related except for the first one which is the front page (‘aperatura’ is something like ‘opening’). Although that XPath was very short, it contains things you might not now. Let’s explain it:</p>
<ul>
<li>
<code>//section</code> find all section tags in the XML document</li>
<li>
<code>[count(.//article])]</code> counts all articles <em>but</em> all articles below the current tag. That’s why we write <code>.//article</code> because the dot (<code>.</code>) signals that we will search for all articles below the current position. If instead we wrote <code>//article</code> it would search for <em>all</em> articles in the entire HTML tree.</li>
<li>
<code>[count(.//article])]&gt;3</code> counts all sections that have more than three articles</li>
</ul>
<p>These XPath filtering rules can take you a long way in building precise expressions. This chapter covers a somewhat beginner/intermediate introduction to XPath but one that can take you very far. Trust me when I tell you that these XPath rules can fulfill a vast percentage of your webscraping needs, if you start easy. Once you start building scraping programs that are supposed to run on frequent intervals or work with a bigger team of developers that is dependent on your scraped data, you might need to be more careful in how you build your XPath expressions to avoid breaking the scraper frequently. However, this is a fairly good start to achieving most of the scraping needs as a beginner.</p>
</div>
<div id="xpath-cookbook" class="section level2" number="5.3">
<h2>
<span class="header-section-number">5.3</span> XPath cookbook<a class="anchor" aria-label="anchor" href="#xpath-cookbook"><i class="fas fa-link"></i></a>
</h2>
<p>I’ve written down a set of cookbook commands that you might find useful when doing webscraping using XPath:</p>
<div class="sourceCode" id="cb181"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Find all sections</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section"</span><span class="op">)</span>

<span class="co"># Return all divs below all sections</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section//div"</span><span class="op">)</span>

<span class="co"># Return all sections which a div as a child</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section/div"</span><span class="op">)</span>

<span class="co"># Return the child (any, because of *) of all sections</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section/*"</span><span class="op">)</span>

<span class="co"># Return all a tags of all section tags which have two nodes in between</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section/*/*/a"</span><span class="op">)</span>

<span class="co"># Return all a tags below all section tags without a class attribute</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section//a[not(@class)]"</span><span class="op">)</span>

<span class="co"># Return all a tags below all section tags that contain a class attribute</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section//a[@class]"</span><span class="op">)</span>

<span class="co"># Return all a tags of all section tags which have two nodes in between</span>
<span class="co"># and contain some text in the a tag.</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section/*/*/a[contains(text(), 'Science')]"</span><span class="op">)</span>

<span class="co"># Return all span tags in the document with a specific class</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//span[@class='c_a_l']"</span><span class="op">)</span>

<span class="co"># Return all span tags in the document that don't have a specific class</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//span[@class!='c_a_l']"</span><span class="op">)</span>

<span class="co"># Return all a tags where an attribute starts with something</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//a[starts-with(@href, 'https://')]"</span><span class="op">)</span>

<span class="co"># Return all a tags where an attribute contains some text</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//a[contains(@href, 'science-tech')]"</span><span class="op">)</span>

<span class="co"># Return all section tags which have tag *descendants (because of the .//)* that have a class attribute</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section[.//a[@class]]"</span><span class="op">)</span>

<span class="co"># Return all section tags which have &lt;td&gt; children</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"//section[td]"</span><span class="op">)</span>

<span class="co"># Return the first occurrence of a section tag</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"(//section)[1]"</span><span class="op">)</span>

<span class="co"># Return the last occurrence of a section tag</span>
<span class="va">newspaper</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="http://xml2.r-lib.org/reference/xml_find_all.html">xml_find_all</a></span><span class="op">(</span><span class="st">"(//section)[last()]"</span><span class="op">)</span></code></pre></div>
</div>
<div id="conclusion-1" class="section level2" number="5.4">
<h2>
<span class="header-section-number">5.4</span> Conclusion<a class="anchor" aria-label="anchor" href="#conclusion-1"><i class="fas fa-link"></i></a>
</h2>
<p>XPath is a very rich language with over 20 years of development. I’ve covered some basics as well as intermediate parts of the language but there’s much more to be learned. I encourage you to look at examples online and to check out additional resources. Below I leave you with some of the best resources that have worked for me:</p>
<ul>
<li><a href="https://devhints.io/xpath">XPath Cheetsheet</a></li>
<li><a href="https://www.lambdatest.com/blog/most-exhaustive-xpath-locators-cheat-sheet/">Extensive XPath Cheetsheet</a></li>
<li><a href="https://www.w3schools.com/xml/xpath_intro.asp">XPath tutorial</a></li>
</ul>
</div>
<div id="exercises-3" class="section level2" number="5.5">
<h2>
<span class="header-section-number">5.5</span> Exercises<a class="anchor" aria-label="anchor" href="#exercises-3"><i class="fas fa-link"></i></a>
</h2>
<ol style="list-style-type: decimal">
<li><p>How many <code>jpg</code> and <code>png</code> images are there in the website? (Hint: look at the source code and figure out which tag and <em>attribute</em> contains the links to the images).</p></li>
<li><p>How many articles are there in the entire website?</p></li>
<li><p>Out of all the headlines (by headlines I mean the bold text that each article begins with), how many contain the word ‘climate’?</p></li>
<li><p>What is the city with more reporters?</p></li>
<li><p>What is the headline of the article with the most words in the description? (Hint: remember that <code>.//</code> searcher for all tags but <em>only below</em> the current tag. <code>//</code> will search for all tags in the document, regardless of whether it’s above the current selected node) The text you’ll want to measure the amount of letters is below the bold headline of each news article:</p></li>
</ol>
<div class="inline-figure"><img src="images/xpath/description_text.png" width="100%" style="display: block; margin: auto;"></div>

</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="regex.html"><span class="header-section-number">4</span> What you need to know about regular expressions</a></div>
<div class="next"><a href="spanish-school.html"><span class="header-section-number">6</span> Case study: Scraping Spanish school locations from the web</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#xpath-chapter"><span class="header-section-number">5</span> What you need to know about XPath</a></li>
<li><a class="nav-link" href="#finding-tags-with-xpath"><span class="header-section-number">5.1</span> Finding tags with XPath</a></li>
<li><a class="nav-link" href="#filter-by-attributes"><span class="header-section-number">5.2</span> Filter by attributes</a></li>
<li><a class="nav-link" href="#xpath-cookbook"><span class="header-section-number">5.3</span> XPath cookbook</a></li>
<li><a class="nav-link" href="#conclusion-1"><span class="header-section-number">5.4</span> Conclusion</a></li>
<li><a class="nav-link" href="#exercises-3"><span class="header-section-number">5.5</span> Exercises</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/cimentadaj/dataharvesting/blob/main/book/05-xpath.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/cimentadaj/dataharvesting/edit/main/book/05-xpath.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Data Harvesting with R</strong>" was written by Jorge Cimentada. It was last built on 2024-02-12.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer>
</body>
</html>
